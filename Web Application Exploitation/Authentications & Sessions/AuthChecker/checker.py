import os
import time
import requests
from bs4 import BeautifulSoup
import re
import math
from collections import Counter

class AuthChecker:

    def __init__(self):
        #self.page_url = input("Enter the URL to test: ")
        #self.username = input("Enter the username for testing: ")
        #self.password = input("Enter the password for testing: ")
        self.session = requests.Session()

    def color(self, text, color):
        colors = {
            "red": "\033[91m",
            "green": "\033[92m",
            "yellow": "\033[93m",
            "blue": "\033[94m",
            "purple": "\033[95m",
            "cyan": "\033[96m"
        }
        return colors.get(color, "") + text + "\033[0m"

#--------------------------------------------
    def check_login_page(self):
        response = self.session.get(self.target_url)
        soup = BeautifulSoup(response.content, 'html.parser')

        # Identify forms in the HTML
        forms = soup.find_all('form')

        login_form_detected = False

        for form in forms:
            inputs = form.find_all('input')
            input_names = [i.get('name') for i in inputs if i.get('name')]

            # Check common input names indicative of login forms
            if "username" in input_names or "password" in input_names or "login" in input_names:
                login_form_detected = True
                print(self.color("[INFO] Login form detected!", "green"))
                print(self.color("[DETAIL] Action URL: " + form.get('action'), "blue"))
                print(self.color("[DETAIL] Method: " + form.get('method'), "blue"))
                for input_field in inputs:
                    print(self.color("[DETAIL] Input field name: " + input_field.get('name', "N/A"), "blue"))

        if not login_form_detected:
            print(self.color("[INFO] No login form detected on the provided page.", "red"))

#--------------------------------------------

    def brute_force_attack_simulation(self, usernames, passwords, form_action_url, user_field_name, pass_field_name):
        for username in usernames:
            for password in passwords:
                payload = {
                    user_field_name: username,
                    pass_field_name: password
                }
                
                response = self.session.post(form_action_url, data=payload)
                
                # You need a condition to identify a successful login
                if "Welcome" in response.text:
                    print(self.color(f"[SUCCESS] Found credentials: {username}:{password}", "green"))
                    return username, password
                
                # Alternatively, check for failure messages
                elif "Login Failed" in response.text:
                    print(self.color(f"[FAILED] Invalid credentials tried: {username}:{password}", "red"))
                    
                else:
                    print(self.color("[UNKNOWN] Response received was not recognized. Adjust the detection mechanism.", "yellow"))
                    
        print(self.color("[INFO] Brute force attack simulation completed.", "blue"))

#--------------------------------------------
    def password_policy_check(self, page_url):
        # Fetch the registration or change password page
        response = self.session.get(page_url)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Search for password policy clues
        policy_clues = [
            ("Minimum Length", ["minimum length", "min length"]),
            ("Uppercase", ["uppercase", "capital letter"]),
            ("Lowercase", ["lowercase"]),
            ("Digit", ["digit", "number"]),
            ("Special Character", ["special character", "symbol"]),
            ("Maximum Length", ["maximum length", "max length"]),
        ]
        
        detected_policies = []

        for policy, clues in policy_clues:
            for clue in clues:
                if clue in soup.get_text().lower():
                    detected_policies.append(policy)
                    break

        if detected_policies:
            print(self.color("[INFO] Detected Password Policies:", "blue"))
            for policy in detected_policies:
                print(self.color(f"- {policy}", "green"))
        else:
            print(self.color("[WARNING] No specific password policies detected. The site may have a generic policy or none at all.", "yellow"))
#--------------------------------------------
        
    def session_fixation_check(self, page_url, username, password):
        # Initiate an anonymous session and capture the session ID
        initial_response = self.session.get(page_url)
        initial_session_id = self.session.cookies.get('SESSIONID')  # Assuming cookie name is 'SESSIONID'

        # Parse the login form using BeautifulSoup
        soup = BeautifulSoup(initial_response.text, 'html.parser')
        login_form = soup.find('form')  # Assuming there's only one form on the page
        
        if not login_form:
            print(self.color("[ERROR] Unable to find a login form on the provided URL.", "red"))
            return

        form_parameters = {}
        for input_tag in login_form.find_all('input'):
            input_name = input_tag.get('name')
            if input_name:
                if "user" in input_name.lower():
                    form_parameters[input_name] = username
                elif "pass" in input_name.lower():
                    form_parameters[input_name] = password

        # Check if we have both username and password fields
        if not (username in form_parameters.values() and password in form_parameters.values()):
            print(self.color("[ERROR] Could not detect the username and/or password fields.", "red"))
            return

        # Simulate login using extracted form parameters
        login_response = self.session.post(page_url, data=form_parameters)

        # Capture session ID after login
        post_login_session_id = self.session.cookies.get('SESSIONID')

        # Check if session ID changed
        if initial_session_id and post_login_session_id and initial_session_id == post_login_session_id:
            print(self.color("[WARNING] Session Fixation vulnerability detected. Session ID does not change post authentication.", "yellow"))
        else:
            print(self.color("[INFO] Session ID changes post authentication. Not vulnerable to session fixation.", "green"))

#--------------------------------------------

    def session_timeout_check(self, test_url, page_url=None, username=None, password=None):
        """
        Check for session timeouts by logging in, waiting for a certain amount of time, and then trying to access again.

        :param test_url: A URL within the application to test the session on.
        :param page_url: The URL of the login page (if authentication is required).
        :param username: The username for authentication (if required).
        :param password: The password for authentication (if required).
        """
        
        # If login details are provided, simulate a login
        if page_url and username and password:
            form_parameters = {
                'username': username,  # Adjust parameter names based on your application
                'password': password
            }
            response = self.session.post(page_url, data=form_parameters)

            if response.status_code != 200:
                print(self.color("[ERROR] Login failed. Please verify the credentials and login URL.", "red"))
                return

        # Obtain the initial session token (like a cookie) - for demonstration, we're using 'SESSIONID'
        initial_session_id = self.session.cookies.get('SESSIONID')
        if not initial_session_id:
            print(self.color("[ERROR] Couldn't obtain a session token. Please verify the login process.", "red"))
            return

        print(self.color(f"[INFO] Obtained session token: {initial_session_id}. Waiting to check for timeout...", "blue"))

        # Wait for a predefined time (e.g., 5 minutes) to see if session times out
        time.sleep(300)

        # Try accessing the application with the session token
        response = self.session.get(test_url)

        # Analyze the response to see if our session is still valid.
        # This is a basic check and may need to be adjusted based on the application's response.
        if response.status_code == 200:
            print(self.color("[WARNING] Session token did not timeout. This might be a security concern.", "yellow"))
        else:
            print(self.color("[INFO] Session token seems to have timed out as expected.", "green"))
#--------------------------------------------

    def token_predictability_check(self, page_url, username, password, token_pattern=r"token=\w+"):
        """
        Enhanced check for the predictability of session tokens.
        """
        
        generated_tokens = []
        num_tokens = 100

        for _ in range(num_tokens):
            form_parameters = {
                'username': username,
                'password': password
            }
            response = self.session.post(page_url, data=form_parameters)

            token_match = re.search(token_pattern, response.text)
            if token_match:
                token_value = token_match.group().split('=')[1]
                generated_tokens.append(token_value)
            else:
                print(self.color("[ERROR] Couldn't extract token from response. Adjust your token_pattern.", "red"))
                return
            
            time.sleep(1)  # introduce a delay to avoid rapid login attempts

        # Shannon Entropy Calculation
        entropy = self.calculate_entropy(''.join(generated_tokens))

        # Token Length Analysis
        average_length = sum(len(token) for token in generated_tokens) / num_tokens
        token_length_issue = average_length < 20  # Just an example; adjust as needed

        # Character Distribution
        char_distribution = Counter(''.join(generated_tokens))
        char_dist_issue = any(v > num_tokens * 0.6 for v in char_distribution.values())

        if entropy > 3.5 and not token_length_issue and not char_dist_issue:
            print(self.color("[INFO] Tokens seem to be sufficiently random.", "green"))
        else:
            print(self.color("[ALERT] Tokens might have predictability issues!", "red"))

    def calculate_entropy(self, s):
        """
        Calculate Shannon entropy of a string.
        """
        p, lns = Counter(s), float(len(s))
        return -sum(count/lns * math.log(count/lns, 2) for count in p.values())
#--------------------------------------------
        
    def insecure_password_recovery_check(self, page_url):
        """
        Attempt to identify potential weaknesses or misconfigurations in password recovery mechanisms.
        """

        # Simulate accessing the password recovery page
        response = self.session.get(page_url)
        if response.status_code != 200:
            print(self.color("[WARNING] Couldn't access the password recovery page!", "yellow"))
            return

        soup = BeautifulSoup(response.content, 'html.parser')

        # Check if security questions are being used (often they are guessable or easy to bypass)
        security_questions = ["What's your mother's maiden name?", "What was your first pet's name?", 
                            "What was your first school?", "What's your favorite movie?"]

        for question in security_questions:
            if question.lower() in response.content.decode().lower():
                print(self.color(f"[ALERT] Detected potentially insecure security question: '{question}'", "red"))

        # Check if the recovery form uses CAPTCHA (to prevent automated attempts)
        if "captcha" not in response.content.decode().lower():
            print(self.color("[ALERT] Password recovery form does not use CAPTCHA, potentially allowing for automated attempts!", "red"))

        # Check for any information disclosure like "This email does not exist in our database" which can be abused
        # Just simulating as a POST request; in a real-world scenario, you'd want to provide valid data
        post_response = self.session.post(page_url, data={'email': 'test@example.com'})

        if "email does not exist" in post_response.content.decode().lower():
            print(self.color("[ALERT] The application discloses whether an email exists in its database!", "red"))

        print(self.color("[INFO] Password recovery checks completed.", "blue"))
#--------------------------------------------
    def run_checks(self):
        """
        The main driver function to execute all checks.
        """

        # Ask the user for the URL
        page_url = input(self.color("[INPUT] Please enter the URL you wish to test: ", "green"))

        # Check if the URL is valid
        if not page_url.startswith('http://') and not page_url.startswith('https://'):
            print(self.color("[ERROR] Invalid URL format!", "red"))
            return

        print(self.color("[INFO] Starting authentication and session management checks...", "blue"))

        # Run the individual functions
        self.brute_force_attack_simulation(page_url)
        self.password_policy_check(page_url)
        self.session_fixation_check(page_url)
        self.session_timeout_check(page_url)
        self.token_predictability_check(page_url)
        self.insecure_password_recovery_check(page_url)

        print(self.color("[INFO] Checks completed.", "blue"))
  
    def menu(self):
        """
        Displays a menu to the user and runs the selected checks.
        """
        while True:
            print(self.color("\n== SecureAxis Authentication & Session Management Tool ==", "cyan"))
            print(self.color("1. Brute Force Attack Simulation", "yellow"))
            print(self.color("2. Password Policy Check", "yellow"))
            print(self.color("3. Session Fixation Check", "yellow"))
            print(self.color("4. Session Timeout Check", "yellow"))
            print(self.color("5. Token Predictability Check", "yellow"))
            print(self.color("6. Insecure Password Recovery Check", "yellow"))
            print(self.color("7. Run All Checks", "yellow"))
            print(self.color("8. Exit", "yellow"))

            choice = input(self.color("[INPUT] Select an option: ", "green"))

            # URL input for the checks
            if choice in ['1', '2', '3', '4', '5', '6', '7']:
                page_url = input(self.color("[INPUT] Please enter the URL you wish to test: ", "green"))

                # Check if the URL is valid
                if not page_url.startswith('http://') and not page_url.startswith('https://'):
                    print(self.color("[ERROR] Invalid URL format!", "red"))
                    continue

            # Execute the chosen function
            if choice == '1':
                self.brute_force_attack_simulation(page_url)
            elif choice == '2':
                self.password_policy_check(page_url)
            elif choice == '3':
                self.session_fixation_check(page_url)
            elif choice == '4':
                self.session_timeout_check(page_url)
            elif choice == '5':
                self.token_predictability_check(page_url)
            elif choice == '6':
                self.insecure_password_recovery_check(page_url)
            elif choice == '7':
                self.run_checks()
            elif choice == '8':
                print(self.color("[INFO] Exiting the tool. Goodbye!", "blue"))
                break
            else:
                print(self.color("[ERROR] Invalid selection. Please choose a number between 1 and 8.", "red"))

    def run(self):
            """
            A main execution loop to continuously display the menu until the user decides to exit.
            """
            print(self.color("\nWelcome to SecureAxis Authentication & Session Management Tool", "cyan"))
            print(self.color("Providing state-of-the-art offensive security solutions.", "cyan"))
            print(self.color("-------------------------------------------------------------", "blue"))
            print("")
            self.menu()

    def clear(self):
        """
        Clears the terminal screen.
        """
        os.system('cls' if os.name == 'nt' else 'clear')
if __name__ == "__main__":
    checker = AuthChecker()
    checker.clear()
    checker.run()